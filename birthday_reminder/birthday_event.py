import enum
from dataclasses import dataclass
from datetime import datetime

from dateutil.relativedelta import relativedelta
from strenum import StrEnum

from .configs.main_config import MainConfig
from .utils.colorize import Colorize


@dataclass
class BirthdayEvent:
    date: datetime
    title: str
    has_year: bool
    config: MainConfig | None = None
    google_event: dict | None = None
    is_manually_created_google_event: bool = False

    @property
    def date_no_year(self):
        return self.date.replace(year=datetime.now().year)

    @property
    def age(self):
        now = datetime.now()
        was_birthday_this_year = (now.month, now.day) >= (self.date.month, self.date.day)
        return now.year - self.date.year - (not was_birthday_this_year)

    @property
    def next_birthday(self):
        next_birthday = self.date + relativedelta(years=self.age + 1)
        return next_birthday

    @property
    def days_until_next_birthday(self):
        return (self.next_birthday - datetime.now()).days

    _ZODIAC_SIGNS = [
        (("Capricorn", "♑"), (1, 19)),
        (("Aquarius", "♒"), (2, 18)),
        (("Pisces", "♓"), (3, 20)),
        (("Aries", "♈"), (4, 19)),
        (("Taurus", "♉"), (5, 20)),
        (("Gemini", "♊"), (6, 20)),
        (("Cancer", "♋"), (7, 22)),
        (("Leo", "♌"), (8, 22)),
        (("Virgo", "♍"), (9, 22)),
        (("Libra", "♎"), (10, 22)),
        (("Scorpio", "♏"), (11, 21)),
        (("Sagittarius", "♐"), (12, 21)),
        (("Capricorn", "♑"), (12, 31)),  # to handle the case of dates after Dec 21
    ]

    @property
    def zodiac(self):
        for sign in self._ZODIAC_SIGNS:
            if (self.date.month, self.date.day) <= sign[1]:
                return sign[0]
        raise Exception("Date is invalid. That's weird. Shouldn't get here")

    @property
    def _zodiac_str(self):
        zodiac_str = ""
        if self.config and self.config.use_zodiac_signs:
            zodiac_str += f" {self.zodiac[1]}"
        if self.config and self.config.use_zodiac_names:
            zodiac_str += f" ({self.zodiac[0]})"
        return zodiac_str

    @property
    def display_title(self):
        if self.google_event:
            return self.google_event["summary"]

        return f"{self.title}{self._zodiac_str}"

    _UNIQUE_TAG = "#birthday_reminder"
    _DATE_OF_BIRTH_KEY = "Date of birth"
    _NO_YEAR_PLACEHOLDER = "...."

    @property
    def description_for_google_calendar(self):
        if self.has_year:
            date_of_birth = self.date.strftime("%Y-%m-%d")
        else:
            date_of_birth = self.date.strftime(f"{self._NO_YEAR_PLACEHOLDER}-%m-%d")

        description = ""
        description += f"{self._DATE_OF_BIRTH_KEY}: {date_of_birth}\n"
        description += f"Zodiac sign: {self.zodiac[1]} ({self.zodiac[0]})\n"
        description += f"Generated by 'Birthday Reminder' on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        description += f"{self._UNIQUE_TAG}\n"
        return description

    def __str__(self):
        # if google event and not generated by this program - inform user about data loss risks
        if self.is_manually_created_google_event:
            warn_text = Colorize.warning(
                "Not generated by Birthday Reminder. Did you create it manually? "
                "Move it to other calendar or it may be deleted..."
            )
            return f"{self.date.strftime('%Y-%m-%d')} - {self.display_title} - {warn_text}"

        if self.has_year:
            return (
                f"{self.date.strftime('%Y-%m-%d')} - {self.display_title} - {Colorize.info(self.age)} years old "
                f"(Will be {Colorize.info(self.age + 1)} in {Colorize.info(self.days_until_next_birthday)} days)"
            )
        else:
            return (
                f"{self.date.strftime(f'{self._NO_YEAR_PLACEHOLDER}-%m-%d')} - {self.display_title} "
                f"(Next birthday in {Colorize.info(self.days_until_next_birthday)} days)"
            )

    def __eq__(self, other):
        if not isinstance(other, BirthdayEvent):
            return NotImplemented
        return (self.date, self.title, self.has_year) == (other.date, other.title, self.has_year)

    def __hash__(self):
        return hash((self.date, self.title))

    @classmethod
    def from_google_event(cls, google_event):
        start = google_event["start"]
        if "dateTime" in start:
            date_str = start["dateTime"][:10]
        else:
            date_str = start["date"]
        date = datetime.strptime(date_str, "%Y-%m-%d")

        title = google_event["summary"]
        # remove zodiac signs and names from title
        for sign in cls._ZODIAC_SIGNS:
            name, symbol = sign[0]
            title = title.replace(symbol, "")
            title = title.replace(f"({name})", "")
        title = title.strip()

        description = google_event.get("description", "")

        lines = description.split("\n")
        date_of_birth_line = next((line for line in lines if line.startswith(cls._DATE_OF_BIRTH_KEY)), "")
        has_year = cls._NO_YEAR_PLACEHOLDER not in date_of_birth_line

        return BirthdayEvent(
            date=date,
            title=title,
            has_year=has_year,
            google_event=google_event,
            is_manually_created_google_event=cls._UNIQUE_TAG not in description
        )

    @enum.unique
    class SortTypes(StrEnum):
        year = enum.auto()
        date = enum.auto()
        next = enum.auto()

    @classmethod
    def sort_events(cls, events: list, sort_type: SortTypes):
        match sort_type:
            case cls.SortTypes.year:
                events_with_year = sorted([e for e in events if e.has_year], key=lambda d: d.date)
                events_without_year = sorted([e for e in events if not e.has_year], key=lambda d: d.date_no_year)
                return events_with_year + events_without_year
            case cls.SortTypes.date:
                return sorted(events, key=lambda d: d.date_no_year)
            case cls.SortTypes.next:
                return sorted(events, key=lambda d: d.days_until_next_birthday)
            case _:
                raise ValueError(f"Unknown sort type: {sort_type}")
